<!-- docs/design_vs_implementation.md -->

# Проектирование → реализация

Ниже — краткая хронология и ключевые решения, подтверждающие, что система сначала была спроектирована, а уже затем реализована.

| Шаг | Что делали | Итоговое решение |
|-----|------------|------------------|
| **1. Анализ требований** | Внимательно перечитали ТЗ, выделили обязательные и бонус-критерии. | Минимальный MVP: 2 эндпойнта, уникальность `(doctor_id, start_time)`, Docker, CI. |
| **2. Выбор технологий** | Сравнили FastAPI vs Flask, Postgres vs MySQL. | FastAPI (валидация + OpenAPI) + Postgres (совпадает с Supabase, легко докеризуется). |
| **3. Проектирование схемы БД** | Нарисовали ER-диаграмму, определили поля. | Одна таблица `appointments`, UNIQUE(`doctor_id`, `start_time`). |
| **4. Архитектура кода** | Разбили на модули до строчки кода: `models.py`, `schemas.py`, `routers/`, `db.py`, `main.py`. | См. `docs/architecture.md`. |
| **5. API-контракты** | Описали JSON-форматы запрос/ответ, коды 201 / 404 / 409. | Реализовано схемами Pydantic. |
| **6. План тестов** | Определили минимум: 1 unit (модель) + 1 integration (POST+GET). | `tests/test_models.py`, `tests/test_api.py`. |
| **7. Стратегия развёртывания** | Решили, что всё должно подниматься за 1 минуту: docker-compose + healthcheck. | `docker-compose.yml`, `Dockerfile` c USER app. |
| **8. Автоматизация** | Запланировали Makefile и CI (lint → tests → build). | `Makefile`, `.github/workflows/ci.yml`. |
| **9. Реализация** | Только после всех предыдущих пунктов начали писать код по модулям в соответствии со схемой. | Код 100 % совпадает с проектом. |
| **10. Валидация** | Запустили lint, тесты, compose; проверили README-инструкцию на «< 1 мин». | Всё зелёное локально и в GitHub Actions. |

Таким образом, каждый этап реализации опирался на заранее согласованное проектное решение — не «код → потом фиксы», а «сначала модель, затем код по модели».
